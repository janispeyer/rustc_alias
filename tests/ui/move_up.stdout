[_1, _2] -> Left(Retag([fn entry] _1))
[_1, _2] -> Left(Retag([fn entry] _2))
[_1, _2] -> Left(StorageLive(_4))
[_1, _2] -> Left(StorageLive(_5))
[_1, _2] -> Left(_5 = (*_1))
[_1, _2] -> Left(_6 = Eq(const 3_i32, const 0_i32))
[_1, _2] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:4:15: 4:21 (#0), scope: scope[0] }, kind: assert(!move _6, "attempt to divide `{}` by zero", _5) -> [success: bb1, unwind: bb7] })
[_1, _2] -> Left(_7 = Eq(const 3_i32, const -1_i32))
[_1, _2] -> Left(_8 = Eq(_5, const i32::MIN))
[_1, _2] -> Left(_9 = BitAnd(move _7, move _8))
[_1, _2] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:4:15: 4:21 (#0), scope: scope[0] }, kind: assert(!move _9, "attempt to compute `{} / {}`, which would overflow", _5, const 3_i32) -> [success: bb2, unwind: bb7] })
[_1, _2] -> Left(_4 = Div(move _5, const 3_i32))
[_1, _2] -> Left(StorageDead(_5))
[_1, _2] -> Left(StorageLive(_10))
[_1, _2] -> Left(StorageLive(_11))
[_1, _2] -> Left(_11 = &mut _2)
[_1] -> Left(Retag(_11))
[_1] -> Left(StorageLive(_12))
[_1] -> Left(StorageLive(_13))
[_1] -> Left(_13 = &(*_1))
[] -> Left(Retag(_13))
[] -> Left(StorageLive(_14))
[] -> Left(_14 = _4)
[] -> Left(Deinit(_12))
[] -> Left((_12.0: &i32) = move _13)
[] -> Left((_12.1: i32) = move _14)
[] -> Left(Retag(_12))
[] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:5:5: 5:14 (#0), scope: scope[1] }, kind: _10 = <impl FnMut(&i32, i32) as std::ops::FnMut<(&i32, i32)>>::call_mut(move _11, move _12) -> [return: bb3, unwind: bb7] })
[] -> Left(StorageDead(_14))
[] -> Left(StorageDead(_13))
[] -> Left(StorageDead(_12))
[] -> Left(StorageDead(_11))
[] -> Left(StorageDead(_10))
[] -> Left(StorageLive(_15))
[] -> Left(_15 = (*_1))
[] -> Left(_16 = Eq(const 3_i32, const 0_i32))
[] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:6:12: 6:18 (#0), scope: scope[1] }, kind: assert(!move _16, "attempt to divide `{}` by zero", _15) -> [success: bb4, unwind: bb7] })
[] -> Left(_17 = Eq(const 3_i32, const -1_i32))
[] -> Left(_18 = Eq(_15, const i32::MIN))
[] -> Left(_19 = BitAnd(move _17, move _18))
[] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:6:12: 6:18 (#0), scope: scope[1] }, kind: assert(!move _19, "attempt to compute `{} / {}`, which would overflow", _15, const 3_i32) -> [success: bb5, unwind: bb7] })
[] -> Left(_0 = Div(move _15, const 3_i32))
[] -> Left(StorageDead(_15))
[] -> Left(StorageDead(_4))
[] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:7:1: 7:2 (#0), scope: scope[0] }, kind: drop(_2) -> [return: bb6, unwind: bb8] })
[] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:7:2: 7:2 (#0), scope: scope[0] }, kind: return })
[_1, _2] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:7:1: 7:2 (#0), scope: scope[0] }, kind: drop(_2) -> bb8 })
[_1] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:3:1: 7:2 (#0), scope: scope[0] }, kind: resume })
# CFG for move_up
Before
[
    BasicBlockData {
        statements: [
            Retag([fn entry] _1),
            Retag([fn entry] _2),
            StorageLive(_4),
            StorageLive(_5),
            _5 = (*_1),
            _6 = Eq(const 3_i32, const 0_i32),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:4:15: 4:21 (#0),
                    scope: scope[0],
                },
                kind: assert(!move _6, "attempt to divide `{}` by zero", _5) -> [success: bb1, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _7 = Eq(const 3_i32, const -1_i32),
            _8 = Eq(_5, const i32::MIN),
            _9 = BitAnd(move _7, move _8),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:4:15: 4:21 (#0),
                    scope: scope[0],
                },
                kind: assert(!move _9, "attempt to compute `{} / {}`, which would overflow", _5, const 3_i32) -> [success: bb2, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _4 = Div(move _5, const 3_i32),
            StorageDead(_5),
            StorageLive(_10),
            StorageLive(_11),
            _11 = &mut _2,
            Retag(_11),
            StorageLive(_12),
            StorageLive(_13),
            _13 = &(*_1),
            Retag(_13),
            StorageLive(_14),
            _14 = _4,
            Deinit(_12),
            (_12.0: &i32) = move _13,
            (_12.1: i32) = move _14,
            Retag(_12),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:5:5: 5:14 (#0),
                    scope: scope[1],
                },
                kind: _10 = <impl FnMut(&i32, i32) as std::ops::FnMut<(&i32, i32)>>::call_mut(move _11, move _12) -> [return: bb3, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            StorageDead(_14),
            StorageDead(_13),
            StorageDead(_12),
            StorageDead(_11),
            StorageDead(_10),
            StorageLive(_15),
            _15 = (*_1),
            _16 = Eq(const 3_i32, const 0_i32),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:6:12: 6:18 (#0),
                    scope: scope[1],
                },
                kind: assert(!move _16, "attempt to divide `{}` by zero", _15) -> [success: bb4, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _17 = Eq(const 3_i32, const -1_i32),
            _18 = Eq(_15, const i32::MIN),
            _19 = BitAnd(move _17, move _18),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:6:12: 6:18 (#0),
                    scope: scope[1],
                },
                kind: assert(!move _19, "attempt to compute `{} / {}`, which would overflow", _15, const 3_i32) -> [success: bb5, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _0 = Div(move _15, const 3_i32),
            StorageDead(_15),
            StorageDead(_4),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:7:1: 7:2 (#0),
                    scope: scope[0],
                },
                kind: drop(_2) -> [return: bb6, unwind: bb8],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:7:2: 7:2 (#0),
                    scope: scope[0],
                },
                kind: return,
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:7:1: 7:2 (#0),
                    scope: scope[0],
                },
                kind: drop(_2) -> bb8,
            },
        ),
        is_cleanup: true,
    },
    BasicBlockData {
        statements: [],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:3:1: 7:2 (#0),
                    scope: scope[0],
                },
                kind: resume,
            },
        ),
        is_cleanup: true,
    },
]
After
[
    BasicBlockData {
        statements: [
            Retag([fn entry] _1),
            Retag([fn entry] _2),
            StorageLive(_4),
            StorageLive(_5),
            _5 = (*_1),
            _6 = Eq(const 3_i32, const 0_i32),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:4:15: 4:21 (#0),
                    scope: scope[0],
                },
                kind: assert(!move _6, "attempt to divide `{}` by zero", _5) -> [success: bb1, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _7 = Eq(const 3_i32, const -1_i32),
            _8 = Eq(_5, const i32::MIN),
            _9 = BitAnd(move _7, move _8),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:4:15: 4:21 (#0),
                    scope: scope[0],
                },
                kind: assert(!move _9, "attempt to compute `{} / {}`, which would overflow", _5, const 3_i32) -> [success: bb2, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _4 = Div(move _5, const 3_i32),
            StorageDead(_5),
            StorageLive(_10),
            StorageLive(_11),
            _11 = &mut _2,
            Retag(_11),
            StorageLive(_12),
            StorageLive(_13),
            _13 = &(*_1),
            Retag(_13),
            StorageLive(_14),
            _14 = _4,
            Deinit(_12),
            (_12.0: &i32) = move _13,
            (_12.1: i32) = move _14,
            Retag(_12),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:5:5: 5:14 (#0),
                    scope: scope[1],
                },
                kind: _10 = <impl FnMut(&i32, i32) as std::ops::FnMut<(&i32, i32)>>::call_mut(move _11, move _12) -> [return: bb3, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            StorageDead(_14),
            StorageDead(_13),
            StorageDead(_12),
            StorageDead(_11),
            StorageDead(_10),
            StorageLive(_15),
            _15 = (*_1),
            _16 = Eq(const 3_i32, const 0_i32),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:6:12: 6:18 (#0),
                    scope: scope[1],
                },
                kind: assert(!move _16, "attempt to divide `{}` by zero", _15) -> [success: bb4, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _17 = Eq(const 3_i32, const -1_i32),
            _18 = Eq(_15, const i32::MIN),
            _19 = BitAnd(move _17, move _18),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:6:12: 6:18 (#0),
                    scope: scope[1],
                },
                kind: assert(!move _19, "attempt to compute `{} / {}`, which would overflow", _15, const 3_i32) -> [success: bb5, unwind: bb7],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [
            _0 = Div(move _15, const 3_i32),
            StorageDead(_15),
            StorageDead(_4),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:7:1: 7:2 (#0),
                    scope: scope[0],
                },
                kind: drop(_2) -> [return: bb6, unwind: bb8],
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:7:2: 7:2 (#0),
                    scope: scope[0],
                },
                kind: return,
            },
        ),
        is_cleanup: false,
    },
    BasicBlockData {
        statements: [],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:7:1: 7:2 (#0),
                    scope: scope[0],
                },
                kind: drop(_2) -> bb8,
            },
        ),
        is_cleanup: true,
    },
    BasicBlockData {
        statements: [],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:3:1: 7:2 (#0),
                    scope: scope[0],
                },
                kind: resume,
            },
        ),
        is_cleanup: true,
    },
]

[_1, _2] -> Left(Retag([fn entry] _1))
[_1, _2] -> Left(Retag([fn entry] _2))
[_1, _2] -> Left(_0 = const ())
[_1, _2] -> Right(Terminator { source_info: SourceInfo { span: $DIR/move_up.rs:11:26: 11:26 (#0), scope: scope[0] }, kind: return })
# CFG for main::{closure#0}
Before
[
    BasicBlockData {
        statements: [
            Retag([fn entry] _1),
            Retag([fn entry] _2),
            _0 = const (),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:11:26: 11:26 (#0),
                    scope: scope[0],
                },
                kind: return,
            },
        ),
        is_cleanup: false,
    },
]
After
[
    BasicBlockData {
        statements: [
            Retag([fn entry] _1),
            Retag([fn entry] _2),
            _0 = const (),
        ],
        terminator: Some(
            Terminator {
                source_info: SourceInfo {
                    span: $DIR/move_up.rs:11:26: 11:26 (#0),
                    scope: scope[0],
                },
                kind: return,
            },
        ),
        is_cleanup: false,
    },
]

